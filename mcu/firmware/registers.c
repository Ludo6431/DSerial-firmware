#include "registers.h"
#include <c8051f340.h>

void setRegister(unsigned char reg, unsigned char val) {
	// sadly, registers are only directly accessible...
	switch (reg) {
		case 0x80: P0 = val; return;
		//case 0x81: SP = val; return;
		//case 0x82: DPL = val; return;
		//case 0x83: DPH = val; return;
		//case 0x87: PCON = val; return;
		//case 0x88: TCON = val; return;
		//case 0x89: TMOD = val; return;
		case 0x8A: TL0 = val; return;
		case 0x8B: TL1 = val; return;
		case 0x8C: TH0 = val; return;
		case 0x8D: TH1 = val; return;
		case 0x8E: CKCON = val; return;
		//case 0x8F: PSCTL = val; return;
		case 0x90: P1 = val; return;
		//case 0x91: TMR3CN = val; return;
		//case 0x92: TMR3RLL = val; return;
		//case 0x93: TMR3RLH = val; return;
		//case 0x94: TMR3L = val; return;
		//case 0x95: TMR3H = val; return;
		//case 0x96: USB0ADR = val; return;
		//case 0x97: USB0DAT = val; return;
		//case 0x98: SCON = val; return;
		//case 0x98: SCON0 = val; return;
		//case 0x99: SBUF = val; return;
		//case 0x99: SBUF0 = val; return;
		//case 0x9A: CPT1CN = val; return;
		//case 0x9B: CPT0CN = val; return;
		//case 0x9C: CPT1MD = val; return;
		//case 0x9D: CPT0MD = val; return;
		//case 0x9E: CPT1MX = val; return;
		//case 0x9F: CPT0MX = val; return;
		case 0xA0: P2 = val; return;
		//case 0xA1: SPI0CFG = val; return;
		//case 0xA2: SPI0CKR = val; return;
		//case 0xA3: SPI0DAT = val; return;
		case 0xA4: P0MDOUT = val; return;
		case 0xA5: P1MDOUT = val; return;
		case 0xA6: P2MDOUT = val; return;
		case 0xA7: P3MDOUT = val; return;
		//case 0xA8: IE = val; return;
		//case 0xA9: CLKSEL = val; return;
		//case 0xAA: EMI0CN = val; return;
		//case 0xAA: _XPAGE = val; return;
		case 0xAC: SBCON1 = val; return;
		case 0xB0: P3 = val; return;
		//case 0xB1: OSCXCN = val; return;
		//case 0xB2: OSCICN = val; return;
		//case 0xB3: OSCICL = val; return;
		case 0xB4: SBRLL1 = val; return;
		case 0xB5: SBRLH1 = val; return;
		//case 0xB6: FLSCL = val; return;
		//case 0xB7: FLKEY = val; return;
		//case 0xB8: IP = val; return;
		//case 0xB9: CLKMUL = val; return;
		//case 0xBA: AMX0N = val; return;
		//case 0xBB: AMX0P = val; return;
		//case 0xBC: ADC0CF = val; return;
		//case 0xBD: ADC0L = val; return;
		//case 0xBE: ADC0H = val; return;
		//case 0xC0: SMB0CN = val; return;
		//case 0xC1: SMB0CF = val; return;
		//case 0xC2: SMB0DAT = val; return;
		//case 0xC3: ADC0GTL = val; return;
		//case 0xC4: ADC0GTH = val; return;
		//case 0xC5: ADC0LTL = val; return;
		//case 0xC6: ADC0LTH = val; return;
		//case 0xC8: T2CON = val; return;
		case 0xC8: TMR2CN = val; return;
		//case 0xC9: REG0CN = val; return;
		//case 0xCA: RCAP2L = val; return;
		case 0xCA: TMR2RLL = val; return;
		//case 0xCB: RCAP2H = val; return;
		case 0xCB: TMR2RLH = val; return;
		//case 0xCC: TL2 = val; return;
		case 0xCC: TMR2L = val; return;
		//case 0xCD: TH2 = val; return;
		case 0xCD: TMR2H = val; return;
		//case 0xD0: PSW = val; return;
		//case 0xD1: REF0CN = val; return;
		case 0xD4: P0SKIP = val; return;
		case 0xD5: P1SKIP = val; return;
		case 0xD6: P2SKIP = val; return;
		//case 0xD7: USB0XCN = val; return;
		//case 0xD8: PCA0CN = val; return;
		//case 0xD9: PCA0MD = val; return;
		//case 0xDA: PCA0CPM0 = val; return;
		//case 0xDB: PCA0CPM1 = val; return;
		//case 0xDC: PCA0CPM2 = val; return;
		//case 0xDD: PCA0CPM3 = val; return;
		//case 0xDE: PCA0CPM4 = val; return;
		case 0xDF: P3SKIP = val; return;
		//case 0xE0: ACC = val; return;
		//case 0xE1: XBR0 = val; return;
		//case 0xE2: XBR1 = val; return;
		//case 0xE4: IT01CF = val; return;
		//case 0xE4: INT01CF = val; return;
		//case 0xE6: EIE1 = val; return;
		//case 0xE7: EIE2 = val; return;
		//case 0xE8: ADC0CN = val; return;
		//case 0xE9: PCA0CPL1 = val; return;
		//case 0xEA: PCA0CPH1 = val; return;
		//case 0xEB: PCA0CPL2 = val; return;
		//case 0xEC: PCA0CPH2 = val; return;
		//case 0xED: PCA0CPL3 = val; return;
		//case 0xEE: PCA0CPH3 = val; return;
		//case 0xEF: RSTSRC = val; return;
		//case 0xF0: B = val; return;
		//case 0xF1: P0MODE = val; return;
		case 0xF1: P0MDIN = val; return;
		//case 0xF2: P1MODE = val; return;
		case 0xF2: P1MDIN = val; return;
		//case 0xF3: P2MODE = val; return;
		case 0xF3: P2MDIN = val; return;
		//case 0xF4: P3MODE = val; return;
		case 0xF4: P3MDIN = val; return;
		//case 0xF6: EIP1 = val; return;
		//case 0xF7: EIP2 = val; return;
		//case 0xF8: SPI0CN = val; return;
		//case 0xF9: PCA0L = val; return;
		//case 0xFA: PCA0H = val; return;
		//case 0xFB: PCA0CPL0 = val; return;
		//case 0xFC: PCA0CPH0 = val; return;
		//case 0xFD: PCA0CPL4 = val; return;
		//case 0xFE: PCA0CPH4 = val; return;
		//case 0xFF: VDM0CN = val; return;
	}
}

unsigned char getRegister(unsigned char reg) {
	// sadly, registers are only directly accessible...
	switch (reg) {
		case 0x80: return P0;
		//case 0x81: return SP;
		//case 0x82: return DPL;
		//case 0x83: return DPH;
		//case 0x87: return PCON;
		//case 0x88: return TCON;
		//case 0x89: return TMOD;
		case 0x8A: return TL0;
		case 0x8B: return TL1;
		case 0x8C: return TH0;
		case 0x8D: return TH1;
		case 0x8E: return CKCON;
		//case 0x8F: return PSCTL;
		case 0x90: return P1;
		//case 0x91: return TMR3CN;
		//case 0x92: return TMR3RLL;
		//case 0x93: return TMR3RLH;
		//case 0x94: return TMR3L;
		//case 0x95: return TMR3H;
		//case 0x96: return USB0ADR;
		//case 0x97: return USB0DAT;
		//case 0x98: return SCON;
		//case 0x98: return SCON0;
		//case 0x99: return SBUF;
		//case 0x99: return SBUF0;
		//case 0x9A: return CPT1CN;
		//case 0x9B: return CPT0CN;
		//case 0x9C: return CPT1MD;
		//case 0x9D: return CPT0MD;
		//case 0x9E: return CPT1MX;
		//case 0x9F: return CPT0MX;
		case 0xA0: return P2;
		//case 0xA1: return SPI0CFG;
		//case 0xA2: return SPI0CKR;
		//case 0xA3: return SPI0DAT;
		case 0xA4: return P0MDOUT;
		case 0xA5: return P1MDOUT;
		case 0xA6: return P2MDOUT;
		case 0xA7: return P3MDOUT;
		//case 0xA8: return IE;
		//case 0xA9: return CLKSEL;
		//case 0xAA: return EMI0CN;
		//case 0xAA: return _XPAGE;
		case 0xAC: return SBCON1;
		case 0xB0: return P3;
		//case 0xB1: return OSCXCN;
		//case 0xB2: return OSCICN;
		//case 0xB3: return OSCICL;
		case 0xB4: return SBRLL1;
		case 0xB5: return SBRLH1;
		//case 0xB6: return FLSCL;
		//case 0xB7: return FLKEY;
		//case 0xB8: return IP;
		//case 0xB9: return CLKMUL;
		//case 0xBA: return AMX0N;
		//case 0xBB: return AMX0P;
		//case 0xBC: return ADC0CF;
		//case 0xBD: return ADC0L;
		//case 0xBE: return ADC0H;
		//case 0xC0: return SMB0CN;
		//case 0xC1: return SMB0CF;
		//case 0xC2: return SMB0DAT;
		//case 0xC3: return ADC0GTL;
		//case 0xC4: return ADC0GTH;
		//case 0xC5: return ADC0LTL;
		//case 0xC6: return ADC0LTH;
		//case 0xC8: return T2CON;
		case 0xC8: return TMR2CN;
		//case 0xC9: return REG0CN;
		//case 0xCA: return RCAP2L;
		case 0xCA: return TMR2RLL;
		//case 0xCB: return RCAP2H;
		case 0xCB: return TMR2RLH;
		//case 0xCC: return TL2;
		case 0xCC: return TMR2L;
		//case 0xCD: return TH2;
		case 0xCD: return TMR2H;
		//case 0xD0: return PSW;
		//case 0xD1: return REF0CN;
		case 0xD4: return P0SKIP;
		case 0xD5: return P1SKIP;
		case 0xD6: return P2SKIP;
		//case 0xD7: return USB0XCN;
		//case 0xD8: return PCA0CN;
		//case 0xD9: return PCA0MD;
		//case 0xDA: return PCA0CPM0;
		//case 0xDB: return PCA0CPM1;
		//case 0xDC: return PCA0CPM2;
		//case 0xDD: return PCA0CPM3;
		//case 0xDE: return PCA0CPM4;
		case 0xDF: return P3SKIP;
		//case 0xE0: return ACC;
		//case 0xE1: return XBR0;
		//case 0xE2: return XBR1;
		//case 0xE4: return IT01CF;
		//case 0xE4: return INT01CF;
		//case 0xE6: return EIE1;
		//case 0xE7: return EIE2;
		//case 0xE8: return ADC0CN;
		//case 0xE9: return PCA0CPL1;
		//case 0xEA: return PCA0CPH1;
		//case 0xEB: return PCA0CPL2;
		//case 0xEC: return PCA0CPH2;
		//case 0xED: return PCA0CPL3;
		//case 0xEE: return PCA0CPH3;
		//case 0xEF: return RSTSRC;
		//case 0xF0: return B;
		//case 0xF1: return P0MODE;
		case 0xF1: return P0MDIN;
		//case 0xF2: return P1MODE;
		case 0xF2: return P1MDIN;
		//case 0xF3: return P2MODE;
		case 0xF3: return P2MDIN;
		//case 0xF4: return P3MODE;
		case 0xF4: return P3MDIN;
		//case 0xF6: return EIP1;
		//case 0xF7: return EIP2;
		//case 0xF8: return SPI0CN;
		//case 0xF9: return PCA0L;
		//case 0xFA: return PCA0H;
		//case 0xFB: return PCA0CPL0;
		//case 0xFC: return PCA0CPH0;
		//case 0xFD: return PCA0CPL4;
		//case 0xFE: return PCA0CPH4;
		//case 0xFF: return VDM0CN;
		default: return 0;
	}
}
